<!--  
 Sliders.html, a simple javascript equation parser that creats dynamic sliders based on the equation
 based on original work by Hunter Davis, 2010
 Copyright Discursive Labs, LLC
 We still need to decided on a license for our internal tools we share with the community
 So if you'd like this to be gpl, send us an email
 hunter or mark at discursivelabs.com 
 -->


<html>
<script src="raphael.js" type="text/javascript" charset="utf-8"></script> 
<script src="g.raphael.js" type="text/javascript" charset="utf-8"></script> 
<script src="g.line.js" type="text/javascript" charset="utf-8"></script> 
<script src="math.js" type="text/javascript" charset="utf-8"></script> 
<script type="text/javascript">


<!-- OUR ONLY GLOBALS ARE DECLARED HERE- array of variable names to legend info, array of variable names to values graphial graph-->
var arrayLegendHash = new Array();
var arrayValueHash = new Array();
var colorArray = [];


<!-- loadSaved uses the passed variables from the address bar to set equations and hashes -->
function loadSaved() {
	var loadString= String(document.getElementById("savebar").value);
	
	if(loadString.length < 3)
	{
		alert("Could Not Load Saved Function from Hash");
	}
	else
	{

	<!-- Clear the Screen -->
		clearScreen();
	<!-- Set our Equation -->
		var equationStart = loadString.indexOf("?&$")+3;
		if(loadString.indexOf("?&$") > -1){
			var equationEnd = loadString.indexOf("&#");
  		 	var equation = loadString.substring(equationStart,equationEnd);
  	 		equation=equation.replace(/%20/g," ");
	  	 	equation=equation.replace(/%25/g,"%");
  		 	equation=equation.replace(/%28/g,"(");
 	  		equation=equation.replace(/%29/g,")");
   		document.getElementById('mainEquation').value = equation;
		} 
	}  
	
<!-- Set our Titles -->
	var titleHashStart = loadString.indexOf("&#")+2;
	var titleHashEnd = loadString.indexOf("&%");
	if(loadString.indexOf("&#") > 0){
		var TitleHash = loadString.substring(titleHashStart,titleHashEnd);
		TitleHash=TitleHash.replace(/%20/g," ");
		addTitlesToHash(TitleHash);		
	}	
	
<!-- Set our Values -->
	var valueHashStart = loadString.indexOf("&%")+2;
	var valueHashEnd = loadString.indexOf("&*");
	if(loadString.indexOf("&%") > 0){
		var ValueHash = loadString.substring(valueHashStart,valueHashEnd);
		ValueHash=ValueHash.replace(/%20/g," ");
		addValuesToHash(ValueHash);		
	}		
	
	
	parseEquation();	
}

// adds array legend titles to global hash
function addTitlesToHash(titles)
{
	var nextDelimiter = 0;
	var stillParsing = 1;	
	var parseBlock = titles;
	
<!-- Loop through all values in title bar and add them to hash table reference for names -->
	while(stillParsing == 1){
		nextDelimiter = parseBlock.indexOf("&:");
		if(nextDelimiter > -1){
			stopDelimiter = parseBlock.indexOf("&,");
			var myVar = parseBlock.substring(0,nextDelimiter);
			var myLabel = parseBlock.substring(nextDelimiter+2,stopDelimiter);
			parseBlock = parseBlock.substring(stopDelimiter+2,parseBlock.length);
			arrayLegendHash[myVar] = myLabel;
			
		}
		else{
			stillParsing = 0;
		}
	}
// x&:testme&;&,K&:hello&;&,y&:whats up&;&%
}

// adds array variable values to global hash
function addValuesToHash(titles)
{
	var nextDelimiter = 0;
	var stillParsing = 1;	
	var parseBlock = titles;
	
<!-- Loop through all values in title bar and add them to hash table reference for names -->
	while(stillParsing == 1){
		nextDelimiter = parseBlock.indexOf("&:");
		if(nextDelimiter > -1){
			stopDelimiter = parseBlock.indexOf("&,");
			var myVar = parseBlock.substring(0,nextDelimiter);
			var myLabel = parseBlock.substring(nextDelimiter+2,stopDelimiter);
			parseBlock = parseBlock.substring(stopDelimiter+2,parseBlock.length);
			arrayValueHash[myVar] = myLabel;
			
		}
		else{
			stillParsing = 0;
		}
	}
// x&:testme&;&,K&:hello&;&,y&:whats up&;&%
}


<!-- showValue changes the sibling span text of a slider to be its value and recalculates the equation-->
<!-- The overall formula based on the change in this variable -->
function showValue(sliderValue, sliderId) {

   var sliderSubLabel = document.getElementById("sub" + sliderId);
	sliderSubLabel.innerHTML=sliderValue;
	
	<!-- Here we set the value hash with the value -->	
	arrayValueHash[sliderId[sliderId.length-1]] = sliderValue;
	
	solveEquation(document.getElementById('mainEquation').value);


	<!-- Also update the graph -->	
	updateGraph()

   //document.getElementById(sliderId).nextSibling.innerHTML=sliderValue;
}

function renameSlider(sliderName) {
	var sliderNewName = prompt("Enter a new variable name","nonameslider");
   var sliderSubLabel = document.getElementById("slider" + sliderName);
   delete arrayLegendHash[sliderName];
 
<!-- Set our hash key value for this variable, or add a new one if not exist -->
  var sliderVar = sliderName[sliderName.length-1];
  arrayLegendHash[sliderVar] = sliderNewName;  
   
   var newLabel = "(" + sliderName[sliderName.length-1] + ") " + sliderNewName;
   
	sliderSubLabel.innerHTML=newLabel;
	
	solveEquation(document.getElementById('mainEquation').value);


	<!-- Also update the graph -->	
	updateGraph()
	
}

<!-- stringify hash turns the main arrayLegendHash into a string and returns it -->
<!-- the returned string is exactly what hash.concat({key: 'value', key2: 'value'}) is looking for -->
function stringifyHash() {
	var returnString = "";
 	var keys = arrayLegendHash;
    for(var i in keys){
    	returnString += i + "&:" +  arrayLegendHash[i];
    	returnString += "&," 
    }
    returnString += "";
    return returnString;
}

<!-- stringify values hash turns the main arrayValueHash into a string and returns it -->
<!-- the returned string is exactly what hash.concat({key: 'value', key2: 'value'}) is looking for -->
function stringifyValueHash() {
	var returnString = "";
 	var keys = arrayValueHash;
    for(var i in keys){
    	returnString += i + "&:" +  arrayValueHash[i];
    	returnString += "&," 
    }
    returnString += "";
    return returnString;
}

<!-- StringifyPage stringifies the hash as well as the equation -->
function stringifyPage() {
	var stringifiedHash = stringifyHash();
	var stringifiedValuesHash = stringifyValueHash();
	var stringifiedEquation = document.getElementById('mainEquation').value;
	stringifiedEquation=stringifiedEquation.replace(/\s/g,"%20");
	var returnString = "?&$" + stringifiedEquation + "&#" + stringifiedHash + "&%" + stringifiedValuesHash + "&*";
	document.getElementById("savebar").value = returnString;	
}



<!-- moreSliders copies the invisible div slider element "slidertemplate" into a sibling div named sliderOutputX where X=numSliders -->
function moreSliders(varName, varTitle) {

	<!-- Here we set the value hash with the value -->	
	if(!arrayValueHash[varName])
	{
		arrayValueHash[varName] = 0;
	}

	
<!-- clone the slider template but not its style-->
	var newSliders = document.getElementById('slidertemplate').cloneNode(true);
	newSliders.id = '';
	newSliders.style.display = 'block';
		
<!-- loop over all child nodes of slider and name them uniquely sliderID(alpha) -->
	var sliderSubLabel = null;
	var newSlider = newSliders.childNodes;
	for (var i=0;i<newSlider.length;i++) {
		var sliderOutputName = newSlider[i].id;
<!-- if the slider id is a range type, name the container div as the same -->
		if (sliderOutputName){
			if(newSlider[i].type == "range")
			{	
				newSliders.id = "sliderID" + varName; 
				newSlider[i].name = "clonedSlider";
				newSlider[i].value = arrayValueHash[varName];
		   	sliderSubLabelName = "sub" + sliderOutputName + varName;							
			}
		   newSlider[i].id = sliderOutputName + varName;
		}
	}
	
<!-- find the slider template and insert the correct slider behind it  -->
	var insertHere = document.getElementById('slidertemplate');
	insertHere.parentNode.insertBefore(newSliders,insertHere);
	
<!-- Also adds a nice label to the text field -->
   var sliderTitle = document.getElementById("sliderTitle" + varName) 
<!-- If we've got a hashed title for this value, display it -->
   var hashLabelValue = arrayLegendHash[varName];
   if(hashLabelValue){
   	sliderTitle.innerHTML= "(" + varName + ") " + hashLabelValue;
   }
   else{
 		sliderTitle.innerHTML= "(" + varName + ") " + varTitle;
 	}
	
// and also set our slider innerHTML value
	sliderSubLabel = document.getElementById(sliderSubLabelName);
	sliderSubLabel.innerHTML=arrayValueHash[varName];	
	
}

<!-- clearScreen clears out all named elements -->
function clearScreen() {

   arrayLegendHash = new Array();
   arrayValueHash = new Array();
   colorArray = [];

	<!-- loop over the collection of cloned sliders and delete their parents -->
	var cloneSpanCollection = document.getElementsByName("clonedSlider");	
	var cloneSpanCollectionLength = cloneSpanCollection.length;
	for (var i=0;i<cloneSpanCollectionLength;i++) {
		cloneSpanCollection[0].parentNode.parentNode.removeChild(cloneSpanCollection[0].parentNode);
	}
}

<!-- alphaNumericType returns the alphaNumericType of the single char passed -->
<!-- alphaNumericType: 6=open parantheses 5=closed paranthesis 4=operator,  2 =numeric, 1=alpha, 0=unsupported operator-->
function alphaNumericType(singlet) {
   var returnVal;

<!-- The most inclusive test must be done first, to subsecede subsequent tests -->
	if (/[^a-zA-Z0-9. _]/.test(singlet)) {
		returnVal = 0;
	}   
   if (/[\[\(\{]/.test(singlet)) {
   	returnVal = 6;
   	}
    if (/[\]\)\}]/.test(singlet)) {
   	returnVal = 5;
   	}  	
   if (/[\é\ê\ò\ñ\ð\ï\î\í\ì\ë\÷\ö\õ\ô\ó\û\ÿ\ù\ø\ü\ú\þ\ÿ\,\&\@\#\~\_\:\;\+\-\/\*\^\%\\\!]/.test(singlet)) {
   	returnVal = 4;
   	}
   if (/[0-9.]/.test(singlet)) {
   	returnVal = 2;
   	}
   if (/[a-zA-Z]/.test(singlet)) {
   	returnVal = 1;
   	}  	   	   	   	   	   	
	return returnVal;
}

// sin = ú
// cos = ù
// tan = _
// asin = &
// acos = @
// atan = #
// sum = :
// medium = ;
// min = ÿ
// max = þ
// less = ý
// greater = ü
// euler = û
// factorial = ø
// natlogten = ÷
// natlog = ö
// pi = õ
// logtene = ô
// logtwoe = ó
// abs = ò
// ceil = ñë
// exp = ð
// floor = ï
// log = î
// random = í
// round = ì
// sqrt = ë
// fibonacci = ê
// nextprime = é
// replace all known functions with pipeesque characters
// store these pipe characters incrementally in the functions array
function storeAndReplaceFunctions(equation) {
	var sanitizedEquation = equation;

	sanitizedEquation = sanitizedEquation.replace( new RegExp( "nextprime", "gi" ), "é" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "fibonacci", "gi" ), "ê" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "pi", "gi" ), "õ" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "logtene", "gi" ), "ô" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "logtwoe", "gi" ), "ó" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "natlogten", "gi" ), "÷" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "natlog", "gi" ), "ö" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "asin", "gi" ), "&" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "acos", "gi" ), "@" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "atan", "gi" ), "#" );	
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "sin", "gi" ), "ú" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "cos", "gi" ), "ù" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "tan", "gi" ), "_" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "sum", "gi" ), ":" );
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "medium", "gi" ), ";" );				
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "min", "gi" ), "ÿ" );	
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "max", "gi" ), "þ" );	
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "less", "gi" ), "ý" );	
	sanitizedEquation = sanitizedEquation.replace( new RegExp( "greater", "gi" ), "ü" );				
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "euler", "gi" ), "û" );				
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "factorial", "gi" ), "ø" );	
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "abs", "gi" ), "ò" );			
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "ceil", "gi" ), "ñ" );	
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "exp", "gi" ), "ð" );			
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "floor", "gi" ), "ï" );	  		
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "log", "gi" ), "î" );			
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "random", "gi" ), "í" );			
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "round", "gi" ), "ì" );			
    sanitizedEquation = sanitizedEquation.replace( new RegExp( "sqrt", "gi" ), "ë" );				

	return sanitizedEquation;
}
// replace all known pipette characters with function names
function replaceStoredFunctions(sanitizedEquation) {

	var restoredEquation = sanitizedEquation;

	restoredEquation = restoredEquation.replace( new RegExp( "é", "g" ), "nextprime" );
	restoredEquation = restoredEquation.replace( new RegExp( "ê", "g" ), "fibonacci" );
	restoredEquation = restoredEquation.replace( new RegExp( "ò", "g" ), "abs" );
	restoredEquation = restoredEquation.replace( new RegExp( "ñ", "g" ), "ceil" );
	restoredEquation = restoredEquation.replace( new RegExp( "ð", "g" ), "exp" );
	restoredEquation = restoredEquation.replace( new RegExp( "ï", "g" ), "floor" );
	restoredEquation = restoredEquation.replace( new RegExp( "î", "g" ), "log" );
	restoredEquation = restoredEquation.replace( new RegExp( "í", "g" ), "random" );
	restoredEquation = restoredEquation.replace( new RegExp( "ì", "g" ), "round" );
	restoredEquation = restoredEquation.replace( new RegExp( "ë", "g" ), "sqrt" );	
	restoredEquation = restoredEquation.replace( new RegExp( "õ", "g" ), "pi" );
	restoredEquation = restoredEquation.replace( new RegExp( "ô", "g" ), "logtene" );
	restoredEquation = restoredEquation.replace( new RegExp( "ó", "g" ), "logtwoe" );
	restoredEquation = restoredEquation.replace( new RegExp( "÷", "g" ), "natlogten" );
	restoredEquation = restoredEquation.replace( new RegExp( "ö", "g" ), "natlog" );
	restoredEquation = restoredEquation.replace( new RegExp( "ø", "g" ), "factorial" );
	restoredEquation = restoredEquation.replace( new RegExp( "û", "g" ), "euler" );
	restoredEquation = restoredEquation.replace( new RegExp( "ü", "g" ), "greater" );
	restoredEquation = restoredEquation.replace( new RegExp( "ý", "g" ), "less" );
	restoredEquation = restoredEquation.replace( new RegExp( "þ", "g" ), "max" );
	restoredEquation = restoredEquation.replace( new RegExp( "ÿ", "g" ), "min" );	
	restoredEquation = restoredEquation.replace( new RegExp( "ú", "g" ), "sin" );
	restoredEquation = restoredEquation.replace( new RegExp( "ù", "g" ), "cos" );
	restoredEquation = restoredEquation.replace( new RegExp( "_", "g" ), "tan" );
	restoredEquation = restoredEquation.replace( new RegExp( "&", "g" ), "asin" );
	restoredEquation = restoredEquation.replace( new RegExp( "@", "g" ), "acos" );
	restoredEquation = restoredEquation.replace( new RegExp( "#", "g" ), "atan" );	
	restoredEquation = restoredEquation.replace( new RegExp( ":", "g" ), "sum" );
	restoredEquation = restoredEquation.replace( new RegExp( ";", "g" ), "medium" );	
	return restoredEquation
}




<!-- clear the screen and parse the equation -->
function clearAndParseEquation() {
	<!-- clear the screen -->
	clearScreen();
	<!-- parse the equation -->	
	parseEquation();
}

<!-- parseEquation is an algorithm in 3 steps -->
<!-- Step 1 - fill an array with each variable from equation -->
<!-- Step 2 - call moreSliders to create a dynamic slider with each variable from equation -->
<!-- Step 3 - moreSliders also creates a named textual field for the dynamic slider -->
function parseEquation() {	
<!-- Create a variable and relevant info with the equation from mainEquation field -->	
	var rawEquation = storeAndReplaceFunctions(document.getElementById('mainEquation').value);
	
	
<!-- loop through each element of the rawEquation and add each alphanumeric to an unique preserving array -->
<!-- Also, sanity check that open paranthesis match closed parenthesis -->
<!-- while we are looping, also throw the sliders up for each alpha type -->
<!-- This is currently a heinous n^2 algorithm because of programmer laziness and input size -->
	var variableChars=new Array();
	var variableFound = 0;
	var paranthesisCheck = 0;  
	for(var i=0;i<rawEquation.length;i++){
		var innerType = alphaNumericType(rawEquation[i])
		if(innerType == 1){
			var foundMatch = 0; 
			for (var j=0; j<variableChars.length; j++) {
				if( rawEquation[i] == variableChars[j]) {
					foundMatch = 1;				
				}			
			}			
			if (foundMatch == 0)
			{
				variableFound++;
				variableChars[variableChars.length] = rawEquation[i];
				moreSliders(rawEquation[i],"");
			}
		} // end alphamatch test
		else if(innerType == 6)
		{
			paranthesisCheck = paranthesisCheck + 1;
		}
		else if(innerType == 5)
		{
			paranthesisCheck = paranthesisCheck - 1;
		}
	}

	if(paranthesisCheck != 0)
	{
		alert("parenthesis are not fully closed");
		return;
	}	


	<!-- solve the first pass at the equation with zero values -->
	solveEquation(rawEquation);
	
	if(rawEquation.length > 0)
	{
		if(variableFound > 0)
		{
			updateGraph();	
		}
	}	
}

<!-- solveEquation solves the equation presented -->
function solveEquation(rawEquation)
{
	// always trim whitespace
	trimmedEquation = rawEquation.replace(/^\s*/, "").replace(/\s*$/, "");
	//alert(trimmedEquation);
	
	// in direct instances this is called twice, which is heinous but not noticible to user
	origEquation = storeAndReplaceFunctions(trimmedEquation);
	var lenForUs = origEquation.length;
	
<!-- This point is our Recursion, we solve for a smaller paranthesis and recurse --!>
	var openParenIndex = 0;
	var closedParenIndex = 0;
	var firstOpen = -1;
	var lastClosed = -1;
	var continueLoop = 1;

	// loop over the equation finding parenthesis in the FORWARD direction
	for(var i=0;i<lenForUs;i++)
	{
		if(continueLoop == 1)
		{
			// 6 = open, 5 = closed
			if(alphaNumericType(origEquation[i]) == 6)
			{
				openParenIndex++;
				if(firstOpen == -1)
				{
					firstOpen = i;
				}
			}
			else if(alphaNumericType(origEquation[i]) == 5)
			{
				closedParenIndex++;
				lastClosed = i;
			}
			
			// if we've completed a paranthesie pair
			// 1. parse the parenthesie
			// 2. put return value into string instead of parenthesie pair
			// 3. return SolveEquation(newEquationMinusParanthesiePair)
			
			// make sure we have the first parenthesie pair (or outermost)
			if(((openParenIndex + closedParenIndex) > 1) && (openParenIndex == closedParenIndex) )
			{
				// get the insides of this parenthesie
				var insideParenthesies = origEquation.substring(firstOpen+1,lastClosed);
				// if this parenthesie is the entire shebang, return the insides and ignore
				if((firstOpen == 0) && (lastClosed == lenForUs))
				{
					return solveEquation(insideParenthesies);
				}
				
				// if openParenIndex > 1, we can recurse further...
				if(openParenIndex > 1)
				{
					// solve for the inside of Parenthesies
					var parenthesieSolution = solveEquation(insideParenthesies);
					var newEquation = origEquation.substring(0,firstOpen) + parenthesieSolution;
					newEquation = newEquation + origEquation.substring(lastClosed,lenForUs);
					return solveEquation(newEquation);
				}
				else
				{
					continueLoop = 0;
				}
			}
		}
	}	
	
	
	// reset shared loop variables
	openParenIndex = 0;
	closedParenIndex = 0;
	var lastOpen = -1;
	var firstClosed = -1;
	continueLoop = 1;	
	
	// now loop over the input in the REVERSE direction
	for(var i=lenForUs;i>0;i--)
	{
		if(continueLoop == 1)
		{
			// 6 = open, 5 = closed
			if(alphaNumericType(origEquation[i]) == 5)
			{
				closedParenIndex++;
				if(firstClosed == -1)
				{
					firstClosed = i;
				}
			}
			else if(alphaNumericType(origEquation[i]) == 6)
			{
				openParenIndex++;
				lastOpen = i;
			}
			
			// if we've completed a paranthesie pair
			// 1. parse the parenthesie
			// 2. put return value into string instead of parenthesie pair
			// 3. return SolveEquation(newEquationMinusParanthesiePair)
			
			// make sure we have the first parenthesie pair (or outermost)
			if(((openParenIndex + closedParenIndex) > 1) && (openParenIndex == closedParenIndex) )
			{
				// get the insides of this parenthesie
				var insideParenthesies = origEquation.substring(lastOpen+1,firstClosed);
				
				// if this parenthesie is the entire shebang, return the insides and ignore
				if((lastOpen == 0) && (firstClosed == lenForUs))
				{
					return solveEquation(insideParenthesies);
				}
				
				// if openParenIndex > 1, we can recurse further...
				if(openParenIndex > 1)
				{
					// solve for the inside of Parenthesies
					var parenthesieSolution = solveEquation(insideParenthesies);
					var newEquation = origEquation.substring(0,lastOpen) + parenthesieSolution;
					newEquation = newEquation + origEquation.substring(firstClosed,lenForUs);
					return solveEquation(newEquation);
				}
				else
				{
					continueLoop = 0;
				}
			}
		}
	}	


// at this point, we can 	
	
<!-- Create an array with one element per item -->	
	var eachIndividual=new Array();
	var eachIndividualSize = 0;
	var numericalDigits = 0;

	for(var i=0;i<lenForUs;i++){
		// we want consecutive numerical items to be added as a group
		if(alphaNumericType(origEquation[i]) == 2)
		{
			if(i == lenForUs-1)
			{
				  if(numericalDigits > 0)
					{
						numericalDigits++;
						eachIndividual[eachIndividualSize] = origEquation.substring(i-numericalDigits,i+1);
						eachIndividualSize = eachIndividualSize + 1;
						numericalDigits = 0;
					}
					else
					{	
						eachIndividual[eachIndividualSize] = origEquation[i];
						eachIndividualSize = eachIndividualSize + 1;
					}
			}
			else
			{
				numericalDigits = numericalDigits + 1;
			}
		}						
		else
		{
		   if(numericalDigits > 0)
			{
				eachIndividual[eachIndividualSize] = origEquation.substring(i-numericalDigits,i);
				eachIndividualSize = eachIndividualSize + 1;
				numericalDigits = 0;
			}
			// add the non-numeric item at this location
			eachIndividual[eachIndividualSize] = origEquation[i];
			eachIndividualSize = eachIndividualSize + 1;
		}
	
	}
<!-- start looping over the equation, cleaning up variables -->
<!-- alphaNumericType: 6=open parantheses 5=closed paranthesis 4=operator,  2 =numeric, 1=alpha, 0=unsupported operator-->
<!-- loop over the individual element collection and reorganize into a string -->
	var newEquationString = '';
	var skipReplace = 0;
	for(var i=0;i<eachIndividual.length;i++){	

		if(i>0){
			if(alphaNumericType(eachIndividual[i]) == 6 && alphaNumericType(eachIndividual[i-1]) == 2){
				newEquationString += '*';
			}
			if(alphaNumericType(eachIndividual[i]) == 1 && alphaNumericType(eachIndividual[i-1]) == 2){
				newEquationString += '*' + arrayValueHash[eachIndividual[i]];
				skipReplace = 1;
			}	
			if(alphaNumericType(eachIndividual[i]) == 1 && alphaNumericType(eachIndividual[i-1]) == 1){
				newEquationString += '*' + arrayValueHash[eachIndividual[i]];
				skipReplace = 1;
			}						
			if(alphaNumericType(eachIndividual[i]) == 2 && alphaNumericType(eachIndividual[i-1]) == 5){
				newEquationString += '*';
			}				
			if(alphaNumericType(eachIndividual[i]) == 2 && alphaNumericType(eachIndividual[i-1]) == 2){
				newEquationString += '*';
			}								
		}
<!-- replace % signs with actual numerical value (.01) -->		
		if(eachIndividual[i] == '\%'){
			newEquationString += "*(.01)";	
		}
		else
		{		
			if(skipReplace == 0)
			{
				if(alphaNumericType(eachIndividual[i]) == 1)
				{
					newEquationString += arrayValueHash[eachIndividual[i]];
				}
				else
				{
					newEquationString += eachIndividual[i];
				}
			}
			else
			{
				skipReplace = 0;
			}
		}
	}	// end of loop over element collection for loop

<!-- loop over the reconstituted collection and add implicit * between brackets -->
<!-- also, remove white spaces! -->
	var implicitEquationString = '';
	for(var i=0;i<newEquationString.length;i++){
		newStringAlphaType = alphaNumericType(newEquationString[i]);
		if(i > 0){
			if(newStringAlphaType == 3 && alphaNumericType(newEquationString[i-1]) == 3){
				implicitEquationString += '*';
			}			
		}	
		if(newStringAlphaType != ' '){
			implicitEquationString += newEquationString[i];
		}	
	}		


<!-- 	document.getElementById("mainResult").innerHTML=implicitEquationString; -->
	//alert(implicitEquationString);
	
	// this is the old method	
	//parsedEquationResult = "Could Not Parse";
	//implicitEquationString = "return " + implicitEquationString;
	//ourEquationFunction = new Function(implicitEquationString);	
	//alert(ourEquationFunction);
   //parsedEquationResult=ourEquationFunction();	  
   //document.getElementById("mainResult").innerHTML= parsedEquationResult;
	
	if(implicitEquationString != "")
	{
		// restore known function names into the equation
		implicitEquationStringWithFunctions = replaceStoredFunctions(implicitEquationString);
		//alert(implicitEquationString);
		//alert("turns into");
		//alert(implicitEquationStringWithFunctions);
		
		var parsedValue;
		// this is the new math parse method	
		var p = new MathProcessor()
		try{
          parsedValue = p.parse(implicitEquationStringWithFunctions);
    	}catch(e){
        	parsedValue = 0;
    	}
	
	
	document.getElementById("mainResult").innerHTML= parsedValue;
	<!-- Also allow user to edit this in the future -->
	stringifyPage();
	return parsedValue;
	}	
	
<!-- Also allow user to edit this in the future -->
	stringifyPage();
}



function updateGraph()
{
	var subGraphElement = document.getElementById('subgraphChart');
	if(subGraphElement != null)
	{
		document.getElementById('graphChart').removeChild(subGraphElement);
	}

	var myGraphElement = document.createElement("div");
   myGraphElement.id = "subgraphChart";     
        
   myGraphElement.innerHTML = "";
   

   document.getElementById('graphChart').appendChild(myGraphElement); 

	var rGraph = Raphael("subgraphChart");
		
<!-- set txt type -->
	rGraph.g.txtattr.font = "12px 'Fontin Sans', Fontin-Sans, sans-serif";


<!-- storage for multidimensional arrays of X and Y plot values and legend-->
	var myXValues = new Array;
	var myYValues = new Array;
	var YValueOneDimension = new Array;
	var XValueOneDimension = new Array;	
	var legendTxt = "<b>Legend</b><ul>";


<!-- for now X value range is not dynamic, upgrade this later -->
	for(i=0;i<100;i++)
	{
		XValueOneDimension[i] = i;
	} 		

<!-- loop over each variable in the value hash -->
<!-- keys[i] is the variable name like x or y-->
<!-- the hash of keys[i] is the value for said variable-->
	var iterator = 0;
 	var arrayValuekeys = arrayValueHash;
   for(var varName in arrayValuekeys)
   {   
<!-- set the color array -->
		var testColor = colorArray[iterator];
		if(testColor == null)
		{
			colorArray[iterator] = Raphael.getColor();
		}
		
		var testLabel = arrayLegendHash[varName];

		if(testLabel == null)
		{
			testLabel = "Unlabeled";
		}
		legendTxt += "<li><FONT COLOR=\"" + colorArray[iterator] + "\">" + varName + "(" + testLabel + ")" + ": " +  colorArray[iterator] + "</FONT></li>";   
   
<!-- for each variable, loop 100 times and find the equation solution for each loop iteration with that J var set as the value -->
		var originalVarValue = arrayValueHash[varName];  
		YValueOneDimension[0] = 0;
		for(var j=1;j<100;j++)
		{
			arrayValueHash[varName] = j;
			solveEquation(document.getElementById('mainEquation').value);
			YValueOneDimension[j] = document.getElementById("mainResult").innerHTML;
						
		}
		myXValues[iterator] = XValueOneDimension.slice(); 		
<!-- add the Y value dimension into the Y value multi-dimensional Array --> 
<!-- slice makes sure it is passed by value and not by reference --> 
   	myYValues[iterator] = YValueOneDimension.slice();		
		
<!-- reset the key back to original state -->
		arrayValueHash[varName] = originalVarValue;		
   
   	iterator = iterator + 1;
   } 

<!-- reset the equation back to original state -->
	solveEquation(document.getElementById('mainEquation').value);

<!-- append the legend -->               	
	legendTxt += "</ul>"
	var myLegendElement = document.createElement("div");
   myLegendElement.id = "subgraphLegend";     
   myLegendElement.innerHTML = legendTxt;

   document.getElementById('subgraphChart').appendChild(myLegendElement);  
<!-- create the graph -->
<!-- graph requires 2 multidimensional arrays of numbers -->
<!-- the first set of arrays is the X axis values of each variable -->
<!-- the second set of arrays is the Y axis values of each variable -->
	var lines = rGraph.g.linechart(60, 10, 1000, 300, myXValues, myYValues,
											 {nostroke: false, axis: "0 0 1 1", symbol: "o", smooth: true, colors: colorArray}).hoverColumn(function () {
      	              this.tags = rGraph.set();
        	           for (var i = 0, ii = this.y.length; i < ii; i++) {
            	            this.tags.push(rGraph.g.tag(this.x, this.y[i], this.values[i], 160, 10).insertBefore(this).attr([{fill: "#fff"}, {fill: this.symbols[i].attr("fill")}]));
               	     }
	                }, function () {
   	                 this.tags && this.tags.remove();
      	          });
         	       lines.symbols.attr({r: 3});
            	    // lines.lines[0].animate({"stroke-width": 6}, 1000);
               	 // lines.symbols[0].attr({stroke: "#fff"});
                	// lines.symbols[0][1].animate({fill: "#f00"}, 1000);              	               	
}
</script>
<style type="text/css">

span.leftTitle {
  display: inline-block;
  width: 200px;
}

</style>

<title>HTML5+JavaScript Sliders - A work in progress</title>
<body>
<h2>HTML5+JavaScript Sliders - A work in progress</h2>

Equation: <input type="text" id="mainEquation" size="60"/>  = <span id="mainResult">0</span>
<input type="button" value="Parse Equation" onclick="clearAndParseEquation()" />
<h6>
Simply click parse equation, and all variables become dynamic html5 sliders<br>
Use it to easily gauge the effect of multivariable equations in real life<br>
Example: 2x + 3K((y-34x) - (3y/100)) (Could be the cost of a product minus taxes, rates, etc)<br>
**NOTE** - Newer browsers which do not yet support HTML5 sliders will show text entry boxes, graphs may not display
</h6>


 <!-- Invisible Slider Template used to clone sliders -->
	<div id="slidertemplate" name="sliderNameTemplate" style="display: none">
		<span id="sliderTitle" class="leftTitle"></span>
		<input type="range" id="rangesliderID" min="0" max="100" value="0" step="1" onchange="showValue(this.value, this.id)" />
	   <span id="subrangesliderID">0</span>
	   <input type="button" id="Title" value="Rename" onclick="renameSlider(this.id)" />
	</div>
	<br>
	<div id="graphChart"></div>
	<br>Copy the below Equation Hash to continue editing your equation later. <br>
	Paste any Equation Hash here and click Load to Continue editing. <br>
	<input type="text" id="savebar" value="" />
	<input type="button" id="LoadButton" value="Load" onclick="loadSaved()" />
	
<h6>
Functions Implemented: 
	<ol>
	<li>sin and asin</li> 
	<li>cos and acos</li>
	<li>tan and atan</li>
	<li>~ (square root) use like ~(4)</li>
	<li>* (multiplication)</li>
	<li>+ (addition)</li>
	<li>- (negation/minus)</li>
	<li>^ (power) (not working)</li>
	<li>/ (divison)</li>
	<li>% (percentage)</li>
	<li>sum(n1, n2, n) (sum of all numbers)</li>
	<li>medium(n1, n2, n) (average/medium of all numbers) </li>
	<li>min(n1,n2,n) (lowest of all numbers)</li>
	<li>max(n1,n2,n) (greatest of all numbers)</li>
	<li>less(n1,n2) (returns 1 if n1 < n2, 0 if not)</li>
	<li>greater(n1,n2) (returns 1 if n1 > n2, 0 if not)</li>
	<li>euler(n) (returns euler's number * passed in value) </li>
	<li>factorial(n) (returns the nth factorial)</li>
	<li>natlogten(n) (returns the natural logarithm of 10 * passed in value)</li>		
	<li>natlog(n) (returns the natural logarithm of 2 * passed in value)</li>
	<li>logtwoe(n) (returns the base-2 logarithm of E * passed in value)</li>	
	<li>logtene(n) (returns the base-10 logarithm of E * passed in value)</li>	
	<li>pi(n) (returns pi * passed in value)</li>		
	<li>abs(n)	Returns the absolute value of x</li>
	<li>ceil(n)	Returns n, rounded upwards to the nearest integer</li>
	<li>exp(n)	Returns the value of En</li>
	<li>floor(n)	Returns n, rounded downwards to the nearest integer</li>
	<li>log(n)	Returns the natural logarithm (base E) of n</li>
	<li>random(n)	Returns N * a random number between 0 and 1</li>
	<li>round(n)	Rounds n to the nearest integer</li>
	<li>sqrt(n)     Returns the square root of n</li>
	<li>fibonacci(n) Returns the fibbonacci of n</li>
	<li>nextprime(n) Returns the next prime number after n</li>
	</ol>
</h6>	
	
	
	</body>
</html>


