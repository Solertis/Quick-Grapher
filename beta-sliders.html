<!--  
 Sliders.html, a simple javascript equation parser that creats dynamic sliders based on the equation
 based on original work by Hunter Davis, 2010
 Copyright Discursive Labs, LLC
 We still need to decided on a license for our internal tools we share with the community
 So if you'd like this to be gpl, send us an email
 hunter or mark at discursivelabs.com 
 -->


<html>
<script src="raphael.js" type="text/javascript" charset="utf-8"></script> 
<script src="g.raphael.js" type="text/javascript" charset="utf-8"></script> 
<script src="g.line.js" type="text/javascript" charset="utf-8"></script> 
<script type="text/javascript">


<!-- OUR ONLY GLOBALS ARE DECLARED HERE- array of variable names to legend info, array of variable names to values graphial graph-->
var arrayLegendHash = new Array();
var arrayValueHash = new Array();
var colorArray = [];


<!-- loadSaved uses the passed variables from the address bar to set equations and hashes -->
function loadSaved() {
	var addressBarString= String(window.location)

<!-- Clear the Screen -->
	clearScreen();
<!-- Set our Equation -->
	var equationStart = addressBarString.indexOf("?&$")+3;
	if(addressBarString.indexOf("?&$") > 0){
		var equationEnd = addressBarString.indexOf("&#");
   	var equation = addressBarString.substring(equationStart,equationEnd);
   	equation=equation.replace(/%20/g," ");
   	equation=equation.replace(/%25/g,"%");
   	equation=equation.replace(/%28/g,"(");
   	equation=equation.replace(/%29/g,")");
   	document.getElementById('mainEquation').value = equation;
	}   
	
<!-- Set our Titles -->
	var titleHashStart = addressBarString.indexOf("&#")+2;
	var titleHashEnd = addressBarString.indexOf("&%");
	if(addressBarString.indexOf("&#") > 0){
		var TitleHash = addressBarString.substring(titleHashStart,titleHashEnd);
		TitleHash=TitleHash.replace(/%20/g," ");
		addTitlesToHash(TitleHash);		
	}	
	
	parseEquation();	
}

function addTitlesToHash(titles)
{
	var nextDelimiter = 0;
	var stillParsing = 1;	
	var parseBlock = titles;
	
<!-- Loop through all values in title bar and add them to hash table reference for names -->
	while(stillParsing == 1){
		nextDelimiter = parseBlock.indexOf("&:");
		if(nextDelimiter > -1){
			stopDelimiter = parseBlock.indexOf("&,");
			var myVar = parseBlock.substring(0,nextDelimiter);
			var myLabel = parseBlock.substring(nextDelimiter+2,stopDelimiter);
			parseBlock = parseBlock.substring(stopDelimiter+2,parseBlock.length);
			arrayLegendHash[myVar] = myLabel;
			
		}
		else{
			stillParsing = 0;
		}
	}
// x&:testme&;&,K&:hello&;&,y&:whats up&;&%
}

<!-- showValue changes the sibling span text of a slider to be its value and recalculates the equation-->
<!-- The overall formula based on the change in this variable -->
function showValue(sliderValue, sliderId) {

   var sliderSubLabel = document.getElementById("sub" + sliderId);
	sliderSubLabel.innerHTML=sliderValue;
	
	<!-- Here we set the value hash with the value -->	
	arrayValueHash[sliderId[sliderId.length-1]] = sliderValue;
	
	solveEquation(document.getElementById('mainEquation').value);


	<!-- Also update the graph -->	
	updateGraph()

   //document.getElementById(sliderId).nextSibling.innerHTML=sliderValue;
}

function renameSlider(sliderName) {
	var sliderNewName = prompt("Enter a new variable name","nonameslider");
   var sliderSubLabel = document.getElementById("slider" + sliderName);
   delete arrayLegendHash[sliderName];
 
<!-- Set our hash key value for this variable, or add a new one if not exist -->
  var sliderVar = sliderName[sliderName.length-1];
  arrayLegendHash[sliderVar] = sliderNewName;  
   
   var newLabel = "(" + sliderName[sliderName.length-1] + ") " + sliderNewName;
   
	sliderSubLabel.innerHTML=newLabel;
	
	stringifyPage();
	
}

<!-- stringify hash turns the main arrayLegendHash into a string and returns it -->
<!-- the returned string is exactly what hash.concat({key: 'value', key2: 'value'}) is looking for -->
function stringifyHash() {
	var returnString = "";
 	var keys = arrayLegendHash;
    for(var i in keys){
    	returnString += i + "&:" +  arrayLegendHash[i];
    	returnString += "&," 
    }
    returnString += "";
    return returnString;
}

<!-- StringifyPage stringifies the hash as well as the equation -->
function stringifyPage() {
	var stringifiedHash = stringifyHash();
	var stringifiedEquation = document.getElementById('mainEquation').value;
	stringifiedEquation=stringifiedEquation.replace(/\s/g,"%20");
	var returnString = "" + "http://www.hunterdavis.com/discursivelabs/tools/beta-sliders.html?&$" + stringifiedEquation + "&#" + stringifiedHash + "&%";
	document.getElementById("savebar").value = returnString;	
}



<!-- moreSliders copies the invisible div slider element "slidertemplate" into a sibling div named sliderOutputX where X=numSliders -->
function moreSliders(varName, varTitle) {

	<!-- Here we set the value hash with the value -->	
	arrayValueHash[varName] = 0;

	
<!-- clone the slider template but not its style-->
	var newSliders = document.getElementById('slidertemplate').cloneNode(true);
	newSliders.id = '';
	newSliders.style.display = 'block';
	
<!-- loop over all child nodes of slider and name them uniquely sliderID(alpha) -->
	var newSlider = newSliders.childNodes;
	for (var i=0;i<newSlider.length;i++) {
		var sliderOutputName = newSlider[i].id;
<!-- if the slider id is a range type, name the container div as the same -->
		if (sliderOutputName){
			if(newSlider[i].type == "range")
			{	
				newSliders.id = "sliderID" + varName; 
				newSlider[i].name = "clonedSlider";
			}
		   newSlider[i].id = sliderOutputName + varName;
		}
	}
	
<!-- find the slider template and insert the correct slider behind it  -->
	var insertHere = document.getElementById('slidertemplate');
	insertHere.parentNode.insertBefore(newSliders,insertHere);
	
<!-- Also adds a nice label to the text field -->
   var sliderTitle = document.getElementById("sliderTitle" + varName) 
<!-- If we've got a hashed title for this value, display it -->
   var hashLabelValue = arrayLegendHash[varName];
   if(hashLabelValue){
   	sliderTitle.innerHTML= "(" + varName + ") " + hashLabelValue;
   }
   else{
 		sliderTitle.innerHTML= "(" + varName + ") " + varTitle;
 	}
	
}

<!-- clearScreen clears out all named elements -->
function clearScreen() {

   arrayLegendHash = new Array();
   arrayValueHash = new Array();
   colorArray = [];

	<!-- loop over the collection of cloned sliders and delete their parents -->
	var cloneSpanCollection = document.getElementsByName("clonedSlider");	
	var cloneSpanCollectionLength = cloneSpanCollection.length;
	for (var i=0;i<cloneSpanCollectionLength;i++) {
		cloneSpanCollection[0].parentNode.parentNode.removeChild(cloneSpanCollection[0].parentNode);
	}
}

<!-- alphaNumericType returns the alphaNumericType of the single char passed -->
<!-- alphaNumericType: 6=open parantheses 5=closed paranthesis 4=operator,  2 =numeric, 1=alpha, 0=unsupported operator-->
function alphaNumericType(singlet) {
   var returnVal;

<!-- The most inclusive test must be done first, to subsecede subsequent tests -->
	if (/[^a-zA-Z0-9. _]/.test(singlet)) {
		returnVal = 0;
	}   
   if (/[\[\(\{]/.test(singlet)) {
   	returnVal = 6;
   	}
    if (/[\]\)\}]/.test(singlet)) {
   	returnVal = 5;
   	}  	
   if (/[\+\-\/\*\^\%\\\!]/.test(singlet)) {
   	returnVal = 4;
   	}
   if (/[0-9.]/.test(singlet)) {
   	returnVal = 2;
   	}
   if (/[a-zA-Z]/.test(singlet)) {
   	returnVal = 1;
   	}  	   	   	   	   	   	
	return returnVal;
}



<!-- clear the screen and parse the equation -->
function clearAndParseEquation() {
	<!-- clear the screen -->
	clearScreen();
	<!-- parse the equation -->	
	parseEquation();
}

<!-- parseEquation is an algorithm in 3 steps -->
<!-- Step 1 - fill an array with each variable from equation -->
<!-- Step 2 - call moreSliders to create a dynamic slider with each variable from equation -->
<!-- Step 3 - moreSliders also creates a named textual field for the dynamic slider -->
function parseEquation() {	
<!-- Create a variable and relevant info with the equation from mainEquation field -->	
	var rawEquation = document.getElementById('mainEquation').value;
	
	
<!-- loop through each element of the rawEquation and add each alphanumeric to an unique preserving array -->
<!-- Also, sanity check that open paranthesis match closed parenthesis -->
<!-- while we are looping, also throw the sliders up for each alpha type -->
<!-- This is currently a heinous n^2 algorithm because of programmer laziness and input size -->
	var variableChars=new Array();
	var paranthesisCheck = 0;  
	for(var i=0;i<rawEquation.length;i++){
		var innerType = alphaNumericType(rawEquation[i])
		if(innerType == 1){
			var foundMatch = 0; 
			for (var j=0; j<variableChars.length; j++) {
				if( rawEquation[i] == variableChars[j]) {
					foundMatch = 1;				
				}			
			}			
			if (foundMatch == 0)
			{
				variableChars[variableChars.length] = rawEquation[i];
				moreSliders(rawEquation[i],"");
			}
		} // end alphamatch test
		else if(innerType == 6)
		{
			paranthesisCheck = paranthesisCheck + 1;
		}
		else if(innerType == 5)
		{
			paranthesisCheck = paranthesisCheck - 1;
		}
	}

	if(paranthesisCheck != 0)
	{
		alert("parenthesis are not fully closed");
		return;
	}	


	<!-- solve the first pass at the equation with zero values -->
	solveEquation(document.getElementById('mainEquation').value);
	
	if(rawEquation.length > 0)
	{
		updateGraph();	
	}	
}

<!-- solveEquation solves the equation presented -->
function solveEquation(rawEquation)
{
<!-- Create an array with one element per item -->	
	var eachIndividual=new Array();
	for(var i=0;i<rawEquation.length;i++){
		eachIndividual[i] = rawEquation[i];
	}
<!-- start looping over the equation, cleaning up variables -->
	for(var i=0;i<rawEquation.length;i++){		
	<!-- alphaNumericType: 6=open parantheses 5=closed paranthesis 4=operator,  2 =numeric, 1=alpha, 0=unsupported operator-->
		var ourType = alphaNumericType(rawEquation[i]);
		switch(ourType)
		{
			case 0:
				<!-- in case of unsupported operater print unsupported operator -->
				document.getElementById("mainResult").innerHTML="Unsupported Operator";
  				break;  	
			case 1:
				if(i>0){
					if(alphaNumericType(rawEquation[i-1]) == 2){
						eachIndividual[i] = '*' + arrayValueHash[rawEquation[i]];
					}
					else{
					    var whatisit = arrayValueHash[rawEquation[i]];
						eachIndividual[i] = arrayValueHash[rawEquation[i]];
					}
				}
				else {
  					eachIndividual[i] = arrayValueHash[rawEquation[i]];
  				}
	 			break;			
		} <!-- End of Switch Case -->
		
<!-- Check for bad types -->
		if (ourType == 0) {break;}
	} <!-- End of FOr LOOP -->

<!-- loop over the individual element collection and reorganize into a string -->
	var newEquationString = '';
	for(var i=0;i<eachIndividual.length;i++){	

		if(i>0){
			if(alphaNumericType(eachIndividual[i]) == 6 && alphaNumericType(eachIndividual[i-1]) == 2){
				newEquationString += '*';
			}
			if(alphaNumericType(eachIndividual[i]) == 2 && alphaNumericType(eachIndividual[i-1]) == 5){
				newEquationString += '*';
			}				
		//	if(alphaNumericType(eachIndividual[i]) == 2 && alphaNumericType(eachIndividual[i-1]) == 2){
		//		newEquationString += '*';
		//	}								
		}
<!-- replace % signs with actual numerical value (.01) -->		
		if(eachIndividual[i] == '\%'){
			newEquationString += "*(.01)";	
		}
		else
		{
			newEquationString += eachIndividual[i];
		}
	}	// end of loop over element collection for loop

<!-- loop over the reconstituted collection and add implicit * between brackets -->
<!-- also, remove white spaces! -->
	var implicitEquationString = '';
	for(var i=0;i<newEquationString.length;i++){
		newStringAlphaType = alphaNumericType(newEquationString[i]);
		if(i > 0){
			if(newStringAlphaType == 3 && alphaNumericType(newEquationString[i-1]) == 3){
				implicitEquationString += '*';
			}			
		}	
		if(newStringAlphaType != ' '){
			implicitEquationString += newEquationString[i];
		}	
	}		

<!-- try a regular ole javascript eval  -->
<!-- 	document.getElementById("mainResult").innerHTML=implicitEquationString; -->
	//alert(implicitEquationString);
	document.getElementById("mainResult").innerHTML=eval(implicitEquationString);	
<!-- Also allow user to edit this in the future -->
	stringifyPage();
}



function updateGraph()
{
	var subGraphElement = document.getElementById('subgraphChart');
	if(subGraphElement != null)
	{
		document.getElementById('graphChart').removeChild(subGraphElement);
	}

	var myGraphElement = document.createElement("div");
   myGraphElement.id = "subgraphChart";     
        
   myGraphElement.innerHTML = "";
   

   document.getElementById('graphChart').appendChild(myGraphElement); 

	var rGraph = Raphael("subgraphChart");
		
<!-- set txt type -->
	rGraph.g.txtattr.font = "12px 'Fontin Sans', Fontin-Sans, sans-serif";


<!-- storage for multidimensional arrays of X and Y plot values and legend-->
	var myXValues = new Array;
	var myYValues = new Array;
	var YValueOneDimension = new Array;
	var XValueOneDimension = new Array;	
	var legendTxt = "<b>Legend</b><ul>";


<!-- for now X value range is not dynamic, upgrade this later -->
	for(i=0;i<100;i++)
	{
		XValueOneDimension[i] = i;
	} 		

<!-- loop over each variable in the value hash -->
<!-- keys[i] is the variable name like x or y-->
<!-- the hash of keys[i] is the value for said variable-->
	var iterator = 0;
 	var arrayValuekeys = arrayValueHash;
   for(var varName in arrayValuekeys)
   {   
<!-- set the color array -->
		var testColor = colorArray[iterator];
		if(testColor == null)
		{
			colorArray[iterator] = Raphael.getColor();
		}
		
		var testLabel = arrayLegendHash[varName];

		if(testLabel == null)
		{
			testLabel = "Unlabeled";
		}
		legendTxt += "<li><FONT COLOR=\"" + colorArray[iterator] + "\">" + varName + "(" + testLabel + ")" + ": " +  colorArray[iterator] + "</FONT></li>";   
   
<!-- for each variable, loop 100 times and find the equation solution for each loop iteration with that J var set as the value -->
		var originalVarValue = arrayValueHash[varName];  
		for(var j=0;j<100;j++)
		{
			arrayValueHash[varName] = j;
			solveEquation(document.getElementById('mainEquation').value);
			YValueOneDimension[j] = document.getElementById("mainResult").innerHTML;
						
		}
		myXValues[iterator] = XValueOneDimension.slice(); 		
<!-- add the Y value dimension into the Y value multi-dimensional Array --> 
<!-- slice makes sure it is passed by value and not by reference --> 
   	myYValues[iterator] = YValueOneDimension.slice();		
		
<!-- reset the key back to original state -->
		arrayValueHash[varName] = originalVarValue;		
   
   	iterator = iterator + 1;
   } 

<!-- reset the equation back to original state -->
	solveEquation(document.getElementById('mainEquation').value);

<!-- append the legend -->               	
	legendTxt += "</ul>"
	var myLegendElement = document.createElement("div");
   myLegendElement.id = "subgraphLegend";     
   myLegendElement.innerHTML = legendTxt;

   document.getElementById('subgraphChart').appendChild(myLegendElement);  
<!-- create the graph -->
<!-- graph requires 2 multidimensional arrays of numbers -->
<!-- the first set of arrays is the X axis values of each variable -->
<!-- the second set of arrays is the Y axis values of each variable -->
	var lines = rGraph.g.linechart(60, 10, 1000, 300, myXValues, myYValues,
											 {nostroke: false, axis: "0 0 1 1", symbol: "o", smooth: true, colors: colorArray}).hoverColumn(function () {
      	              this.tags = rGraph.set();
        	           for (var i = 0, ii = this.y.length; i < ii; i++) {
            	            this.tags.push(rGraph.g.tag(this.x, this.y[i], this.values[i], 160, 10).insertBefore(this).attr([{fill: "#fff"}, {fill: this.symbols[i].attr("fill")}]));
               	     }
	                }, function () {
   	                 this.tags && this.tags.remove();
      	          });
         	       lines.symbols.attr({r: 3});
            	    // lines.lines[0].animate({"stroke-width": 6}, 1000);
               	 // lines.symbols[0].attr({stroke: "#fff"});
                	// lines.symbols[0][1].animate({fill: "#f00"}, 1000);              	               	
}
</script>
<style type="text/css">

span.leftTitle {
  display: inline-block;
  width: 200px;
}

</style>

<title>HTML5+JavaScript Sliders - A work in progress</title>
<body>
<h2>HTML5+JavaScript Sliders - A work in progress</h2>

Equation: <input type="text" id="mainEquation" size="60"/>  = <span id="mainResult">0</span>
<input type="button" value="Parse Equation" onclick="clearAndParseEquation()" />
<h6>
Simply click parse equation, and all variables become dynamic html5 sliders<br>
Use it to easily gauge the effect of multivariable equations in real life<br>
Example: 2x + 3K((y-34x) - 3y/100)) (Could be the cost of a product minus taxes, rates, etc)<br>
**NOTE** - Newer browsers which do not yet support HTML5 sliders will show text entry boxes
</h6>


 <!-- Invisible Slider Template used to clone sliders -->
	<div id="slidertemplate" name="sliderNameTemplate" style="display: none">
		<span id="sliderTitle" class="leftTitle"></span>
		<input type="range" id="rangesliderID" min="0" max="100" value="0" step="1" onchange="showValue(this.value, this.id)" />
	   <span id="subrangesliderID">0</span>
	   <input type="button" id="Title" value="Rename" onclick="renameSlider(this.id)" />
	</div>
	<br>
	<div id="graphChart"></div>
	<br>Copy the below address into any Browser to continue editing this equation<br>
	<input type="text" id="savebar" value="" />

<script>
<!-- The first thing that happens on load is to load all the old variables if they exist -->
<!-- But we have to wait till after the HTML is loaded for our window elements to be ready to fill -->
	window.onload=loadSaved();
</script>
</body>
</html>


