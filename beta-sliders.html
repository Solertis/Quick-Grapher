<!--  
 Sliders.html, a simple javascript equation parser that creats dynamic sliders based on the equation
 based on original work by Hunter Davis, 2010
 Copyright Discursive Labs, LLC
 We still need to decided on a license for our internal tools we share with the community
 So if you'd like this to be gpl, send us an email
 hunter or mark at discursivelabs.com 
 -->


<html>
<script type="text/javascript">

<!-- very generic hash function from view-source:http://rick.measham.id.au/javascript/hash.htm -->
function Hash(){
	for( var i=0; i < arguments.length; i++ )
		for( n in arguments[i] )
			if( arguments[i].hasOwnProperty(n) )
				this[n] = arguments[i][n];
	}
 
	// Hash.version = 1.00;	// Original version
	// Hash.version = 1.01;	// Added ability to initialize in the constructor
	// Hash.version = 1.02;	// Fixed document bug that showed a non-working example (thanks mareks)
	//Hash.version = 1.03;	// Removed returning this from the constructor (thanks em-dash)
	Hash.version = 1.04;	// Missed some 'var' declarations (thanks Twey)

	Hash.prototype = new Object();

	Hash.prototype.keys = function(){
			var rv = [];
			for( var n in this )
				if( this.hasOwnProperty(n) )
					rv.push(n);
			return rv;
	}
 
	Hash.prototype.length = function(){
		return this.keys().length();
	}
 
	Hash.prototype.values = function(){
		var rv = [];
		for( var n in this )
			if( this.hasOwnProperty(n) )
				rv.push(this[n]);
		return rv;
	}
 
	Hash.prototype.slice = function(){
		var rv = [];
		for( var i = 0; i < arguments.length; i++ )
			rv.push(
				( this.hasOwnProperty( arguments[i] ) )
					? this[arguments[i]]
					: undefined
			);
		return rv;
	}
 
	Hash.prototype.concat = function(){
		for( var i = 0; i < arguments.length; i++ )
			for( var n in arguments[i] )
				if( arguments[i].hasOwnProperty(n) )
					this[n] = arguments[i][n];
		return this;
	}

<!-- OUR ONLY GLOBAL - array of variable names to legend info -->
var arrayLegendHash = new Hash();

<!-- loadSaved uses the passed variables from the address bar to set equations and hashes -->
function loadSaved() {
	var addressBarString= String(window.location)

<!-- Set our Equation -->
	var equationStart = addressBarString.indexOf("?&$")+3;
	if(addressBarString.indexOf("?&$") > 0){
		var equationEnd = addressBarString.indexOf("&#");
   	var equation = addressBarString.substring(equationStart,equationEnd);
   	equation=equation.replace(/%20/g," ");
   	equation=equation.replace(/%25/g,"%");
   	equation=equation.replace(/%28/g,"(");
   	equation=equation.replace(/%29/g,")");
   	document.getElementById('mainEquation').value = equation;
	}   
<!-- Set our Titles -->
	var titleHashStart = addressBarString.indexOf("&#")+2;
	var titleHashEnd = addressBarString.indexOf("&%");
	if(addressBarString.indexOf("&#") > 0){
		var TitleHash = addressBarString.substring(titleHashStart,titleHashEnd);
		TitleHash=TitleHash.replace(/%20/g," ");
		addTitlesToHash(TitleHash);
	}
	parseEquation();
}

function addTitlesToHash(titles)
{
	var nextDelimiter = 0;
	var stillParsing = 1;	
	var parseBlock = titles;
	
<!-- Loop through all values in title bar and add them to hash table reference for names -->
	while(stillParsing == 1){
		nextDelimiter = parseBlock.indexOf("&:");
		if(nextDelimiter > -1){
			stopDelimiter = parseBlock.indexOf("&,");
			var myVar = parseBlock.substring(0,nextDelimiter);
			var myLabel = parseBlock.substring(nextDelimiter+2,stopDelimiter);
			parseBlock = parseBlock.substring(stopDelimiter+2,parseBlock.length);
			arrayLegendHash[myVar] = myLabel;
			
		}
		else{
			stillParsing = 0;
		}
	}
// x&:testme&;&,K&:hello&;&,y&:whats up&;&%
}

<!-- showValue changes the sibling span text of a slider to be its value and recalculates the equation-->
<!-- The overall formula based on the change in this variable -->
function showValue(sliderValue, sliderId) {

   var sliderSubLabel = document.getElementById("sub" + sliderId);
	sliderSubLabel.innerHTML=sliderValue;
	solveEquation(document.getElementById('mainEquation').value);

   //document.getElementById(sliderId).nextSibling.innerHTML=sliderValue;
}

function renameSlider(sliderName) {
	var sliderNewName = prompt("Enter a new variable name","nonameslider");
   var sliderSubLabel = document.getElementById("slider" + sliderName);
 
<!-- Set our hash key value for this variable, or add a new one if not exist -->
   arrayLegendHash[sliderName[sliderName.length-1]] = sliderNewName;
   
   var newLabel = "(" + sliderName[sliderName.length-1] + ") " + sliderNewName;
   
	sliderSubLabel.innerHTML=newLabel;
	
	stringifyPage();
	
}

<!-- stringify hash turns the main arrayLegendHash into a string and returns it -->
<!-- the returned string is exactly what hash.concat({key: 'value', key2: 'value'}) is looking for -->
function stringifyHash() {
	var returnString = "";
 	var keys = arrayLegendHash.keys();
    for(i in keys){
    	returnString +=  keys[i] + "&:" +  arrayLegendHash[keys[i]];
    	returnString += "&," 
    }
    returnString += "";
    return returnString;
}

<!-- StringifyPage stringifies the hash as well as the equation -->
function stringifyPage() {
	var stringifiedHash = stringifyHash();
	var stringifiedEquation = document.getElementById('mainEquation').value;
	stringifiedEquation=stringifiedEquation.replace(/\s/g,"%20");
	var returnString = "" + "http://www.hunterdavis.com/discursivelabs/tools/beta-sliders.html?&$" + stringifiedEquation + "&#" + stringifiedHash + "&%";
	document.getElementById("savebar").value = returnString;	
}



<!-- moreSliders copies the invisible div slider element "slidertemplate" into a sibling div named sliderOutputX where X=numSliders -->
function moreSliders(varName, varTitle) {
	
<!-- clone the slider template but not its style-->
	var newSliders = document.getElementById('slidertemplate').cloneNode(true);
	newSliders.id = '';
	newSliders.style.display = 'block';
	
<!-- loop over all child nodes of slider and name them uniquely sliderID(alpha) -->
	var newSlider = newSliders.childNodes;
	for (var i=0;i<newSlider.length;i++) {
		var sliderOutputName = newSlider[i].id;
<!-- if the slider id is a range type, name the container div as the same -->
		if (sliderOutputName){
			if(newSlider[i].type == "range")
			{	
				newSliders.id = "sliderID" + varName; 
				newSlider[i].name = "clonedSlider";
			}
		   newSlider[i].id = sliderOutputName + varName;
		}
	}
	
<!-- find the slider template and insert the correct slider behind it  -->
	var insertHere = document.getElementById('slidertemplate');
	insertHere.parentNode.insertBefore(newSliders,insertHere);
	
<!-- Also adds a nice label to the text field -->
   var sliderTitle = document.getElementById("sliderTitle" + varName) 
<!-- If we've got a hashed title for this value, display it -->
   var hashLabelValue = arrayLegendHash[varName];
   if(hashLabelValue){
   	sliderTitle.innerHTML= "(" + varName + ") " + hashLabelValue;
   }
   else{
 		sliderTitle.innerHTML= "(" + varName + ") " + varTitle;
 	}
	
}

<!-- clearScreen clears out all named elements -->
function clearScreen() {
	<!-- loop over the collection of cloned sliders and delete their parents -->
	var cloneSpanCollection = document.getElementsByName("clonedSlider");	
	var cloneSpanCollectionLength = cloneSpanCollection.length;
	for (var i=0;i<cloneSpanCollectionLength;i++) {
		cloneSpanCollection[0].parentNode.parentNode.removeChild(cloneSpanCollection[0].parentNode);
	}
}

<!-- alphaNumericType returns the alphaNumericType of the single char passed -->
<!-- alphaNumericType: 6=open parantheses 5=closed paranthesis 4=operator,  2 =numeric, 1=alpha, 0=unsupported operator-->
function alphaNumericType(singlet) {
   var returnVal;

<!-- The most inclusive test must be done first, to subsecede subsequent tests -->
	if (/[^a-zA-Z0-9. _]/.test(singlet)) {
		returnVal = 0;
	}   
   if (/[\[\(\{]/.test(singlet)) {
   	returnVal = 6;
   	}
    if (/[\]\)\}]/.test(singlet)) {
   	returnVal = 5;
   	}  	
   if (/[\+\-\/\*\^\%\\\!]/.test(singlet)) {
   	returnVal = 4;
   	}
   if (/[0-9.]/.test(singlet)) {
   	returnVal = 2;
   	}
   if (/[a-zA-Z]/.test(singlet)) {
   	returnVal = 1;
   	}  	   	   	   	   	   	
	return returnVal;
}


<!-- parseEquation is an algorithm in 3 steps -->
<!-- Step 1 - fill an array with each variable from equation -->
<!-- Step 2 - call moreSliders to create a dynamic slider with each variable from equation -->
<!-- Step 3 - moreSliders also creates a named textual field for the dynamic slider -->
function parseEquation() {
	<!-- clear the screen -->
	clearScreen();
	

<!-- Create a variable and relevant info with the equation from mainEquation field -->	
	var rawEquation = document.getElementById('mainEquation').value;
	
	
<!-- loop through each element of the rawEquation and add each alphanumeric to an unique preserving array -->
<!-- Also, sanity check that open paranthesis match closed parenthesis -->
<!-- while we are looping, also throw the sliders up for each alpha type -->
<!-- This is currently a heinous n^2 algorithm because of programmer laziness and input size -->
	var variableChars=new Array();
	var paranthesisCheck = 0;  
	for(var i=0;i<rawEquation.length;i++){
		var innerType = alphaNumericType(rawEquation[i])
		if(innerType == 1){
			var foundMatch = 0; 
			for (var j=0; j<variableChars.length; j++) {
				if( rawEquation[i] == variableChars[j]) {
					foundMatch = 1;				
				}			
			}			
			if (foundMatch == 0)
			{
				variableChars[variableChars.length] = rawEquation[i];
				moreSliders(rawEquation[i],"");
			}
		} // end alphamatch test
		else if(innerType == 6)
		{
			paranthesisCheck = paranthesisCheck + 1;
		}
		else if(innerType == 5)
		{
			paranthesisCheck = paranthesisCheck - 1;
		}
	}

	if(paranthesisCheck != 0)
	{
		alert("parenthesis are not fully closed");
		return;
	}	

	<!-- solve the first pass at the equation with zero values -->
	solveEquation(document.getElementById('mainEquation').value);
}

<!-- solveEquation solves the equation presented -->
function solveEquation(rawEquation)
{
<!-- Create an array with one element per item -->	
	var eachIndividual=new Array();
	for(var i=0;i<rawEquation.length;i++){
		eachIndividual[i] = rawEquation[i];
	}
<!-- start looping over the equation, cleaning up variables -->
	for(var i=0;i<rawEquation.length;i++){		
	<!-- alphaNumericType: 6=open parantheses 5=closed paranthesis 4=operator,  2 =numeric, 1=alpha, 0=unsupported operator-->
		var ourType = alphaNumericType(rawEquation[i]);
		switch(ourType)
		{
			case 0:
				<!-- in case of unsupported operater print unsupported operator -->
				document.getElementById("mainResult").innerHTML="Unsupported Operator";
  				break;  	
			case 1:
				if(i>0){
					if(alphaNumericType(rawEquation[i-1]) == 2){
						eachIndividual[i] = '*' + document.getElementById("range" + "sliderID" + rawEquation[i]).value;
					}
					else{
					    var whatisit = document.getElementById("range" + "sliderID" + rawEquation[i]);
						eachIndividual[i] = document.getElementById("range" + "sliderID" + rawEquation[i]).value;
					}
				}
				else {
  					eachIndividual[i] = document.getElementById("range" + "sliderID" + rawEquation[i]).value;
  				}
	 			break;			
		} <!-- End of Switch Case -->
		
<!-- Check for bad types -->
		if (ourType == 0) {break;}
	} <!-- End of FOr LOOP -->

<!-- loop over the individual element collection and reorganize into a string -->
	var newEquationString = '';
	for(var i=0;i<eachIndividual.length;i++){	

		if(i>0){
			if(alphaNumericType(eachIndividual[i]) == 6 && alphaNumericType(eachIndividual[i-1]) == 2){
				newEquationString += '*';
			}
			if(alphaNumericType(eachIndividual[i]) == 2 && alphaNumericType(eachIndividual[i-1]) == 5){
				newEquationString += '*';
			}				
		//	if(alphaNumericType(eachIndividual[i]) == 2 && alphaNumericType(eachIndividual[i-1]) == 2){
		//		newEquationString += '*';
		//	}								
		}
<!-- replace % signs with actual numerical value (.01) -->		
		if(eachIndividual[i] == '\%'){
			newEquationString += "*(.01)";	
		}
		else
		{
			newEquationString += eachIndividual[i];
		}
	}	// end of loop over element collection for loop

<!-- loop over the reconstituted collection and add implicit * between brackets -->
<!-- also, remove white spaces! -->
	var implicitEquationString = '';
	for(var i=0;i<newEquationString.length;i++){
		newStringAlphaType = alphaNumericType(newEquationString[i]);
		if(i > 0){
			if(newStringAlphaType == 3 && alphaNumericType(newEquationString[i-1]) == 3){
				implicitEquationString += '*';
			}			
		}	
		if(newStringAlphaType != ' '){
			implicitEquationString += newEquationString[i];
		}	
	}		

<!-- try a regular ole javascript eval  -->
<!-- 	document.getElementById("mainResult").innerHTML=implicitEquationString; -->
	//alert(implicitEquationString);
	document.getElementById("mainResult").innerHTML=eval(implicitEquationString);	
<!-- Also allow user to edit this in the future -->
	stringifyPage();
}


</script>
<style type="text/css">

span.leftTitle {
  display: inline-block;
  width: 200px;
}

</style>

<title>HTML5+JavaScript Sliders - A work in progress</title>
<body>
<h2>HTML5+JavaScript Sliders - A work in progress</h2>

Equation: <input type="text" id="mainEquation" size="60"/>  = <span id="mainResult">0</span>
<input type="button" value="Parse Equation" onclick="parseEquation()" />
<h6>
Simply click parse equation, and all variables become dynamic html5 sliders<br>
Use it to easily gauge the effect of multivariable equations in real life<br>
Example: 2x + 3K((y-34x) - 3y/100)) (Could be the cost of a product minus taxes, rates, etc)<br>
**NOTE** - Newer browsers which do not yet support HTML5 sliders will show text entry boxes
</h6>


 <!-- Invisible Slider Template used to clone sliders -->
	<div id="slidertemplate" name="sliderNameTemplate" style="display: none">
		<span id="sliderTitle" class="leftTitle"></span>
		<input type="range" id="rangesliderID" min="0" max="100" value="0" step="1" onchange="showValue(this.value, this.id)" />
	   <span id="subrangesliderID">0</span>
	   <input type="button" id="Title" value="Rename" onclick="renameSlider(this.id)" />
	</div>
	<br>
	<br>Copy the below address into any Browser to continue editing this equation<br>
	<input type="text" id="savebar" value="" />

<script>
<!-- The first thing that happens on load is to load all the old variables if they exist -->
<!-- But we have to wait till after the HTML is loaded for our window elements to be ready to fill -->
	window.onload=loadSaved();
</script>
</body>
</html>


